use std::{
    collections::HashMap,
    net::{IpAddr, Ipv6Addr},
    sync::{Arc, Mutex},
};

use log;

use anyhow::Result;
use clap::Parser;
use dht::HashNode;
use futures::{future, prelude::*};
use tarpc::{
    context,
    server::{self, Channel},
};
use tarpc::{server::incoming::Incoming, tokio_serde::formats::Json};

#[derive(Debug, Parser)]
struct Flags {
    /// listening port
    #[clap(long)]
    port: u16,
}

type Store = Arc<Mutex<HashMap<String, String>>>;
#[derive(Clone)]
struct HashNodeServer {
    store: Store,
}

impl HashNodeServer {
    pub fn new(store: Store) -> Self {
        HashNodeServer { store }
    }
}

#[tarpc::server]
impl HashNode for HashNodeServer {
    async fn get(self, _: context::Context, key: String) -> Option<String> {
        log::info!("Get({})", &key);
        let store = self.store.lock().unwrap();
        store.get(&key).map(|val| val.to_owned())
    }

    async fn insert(self, _: context::Context, key: String, value: String) -> Option<String> {
        log::info!("Insert({}, {})", &key, &value);
        let mut store = self.store.lock().unwrap();
        let res = store.insert(key, value);
        log::info!("{:?}", res);
        return res;
    }

    async fn remove(self, _: context::Context, key: String) -> Option<String> {
        log::info!("Remove({})", &key);
        let mut store = self.store.lock().unwrap();
        store.remove(&key)
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    log::info!("Starting up");
    let flags = Flags::parse();
    let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), flags.port);
    let store = Arc::new(Mutex::new(HashMap::new()));
    let server = HashNodeServer::new(store);
    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = server.clone();
            channel.execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;

    Ok(())
}
